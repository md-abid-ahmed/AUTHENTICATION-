import React, { useState, useEffect } from 'react';
import axios from 'axios';
import {
  LineChart,
  Line,
  XAxis,
  YAxis,
  CartesianGrid,
  Tooltip,
  Legend,
  ResponsiveContainer,
  Brush
} from 'recharts';
import { CSVLink } from 'react-csv';
import DatePicker from 'react-datepicker';
import 'react-datepicker/dist/react-datepicker.css';
import './Latestappover.css';

interface AppOption {
  value: string;
  label: string;
}

interface UtilizationData {
  app: string;
  datetime: string;
  instance: number;
  instance_type: string;
  state: string;
  value: number;
}

interface ProcessedData {
  name: string;
  [key: string]: number | string;
}

const Latestappover: React.FC = () => {
  const [appOptions, setAppOptions] = useState<AppOption[]>([]);
  const [selectedAppId, setSelectedAppId] = useState<string>('');
  const [startDate, setStartDate] = useState<Date | undefined>(undefined);
  const [endDate, setEndDate] = useState<Date | undefined>(undefined);
  const [utilizationData, setUtilizationData] = useState<UtilizationData[]>([]);
  const [dateRangeType, setDateRangeType] = useState<'daily' | 'weekly' | 'monthly'>('daily');
  const [showInsights, setShowInsights] = useState(false);
  const [selectedInstances, setSelectedInstances] = useState<number[]>([]);
  const [viewMode, setViewMode] = useState<'all' | 'selected'>('all');

  useEffect(() => {
    fetchApps();
  }, []);

  const fetchApps = async () => {
    try {
      const response = await axios.get('/fetch_apps');
      if (response.data && Array.isArray(response.data.Data)) {
        const apps = response.data.Data.map((app: { _id: string }) => ({
          value: app._id,
          label: `AppID: ${app._id}`
        }));
        setAppOptions(apps);
      } else {
        console.error('Unexpected response format from /fetch_apps');
      }
    } catch (error) {
      console.error('Error fetching apps:', error);
    }
  };

  const formatDate = (date: Date): string => {
    return date.toISOString().slice(0, 19).replace('T', ' ') + '.00';
  };

  const fetchUtilizationData = async () => {
    if (!selectedAppId || !startDate || !endDate) return;

    const postData = {
      appID: selectedAppId,
      from_time: formatDate(startDate),
      to_time: formatDate(endDate)
    };

    try {
      const response = await axios.post('/fetch_utilisation', postData);
      if (response.data && Array.isArray(response.data.data)) {
        setUtilizationData(response.data.data);
      } else {
        console.error('Unexpected response format from /fetch_utilisation');
      }
    } catch (error) {
      console.error('Error fetching utilization data:', error);
    }
  };

  const handleCalculate = () => {
    fetchUtilizationData();
  };

  const processUtilizationData = (): ProcessedData[] => {
    const filteredData = utilizationData.filter(item => {
      const itemDate = new Date(item.datetime);
      return (!startDate || itemDate >= startDate) && (!endDate || itemDate <= endDate);
    });

    const dataMap: { [key: string]: ProcessedData } = {};

    filteredData.forEach(item => {
      if (!dataMap[item.datetime]) {
        dataMap[item.datetime] = { name: item.datetime };
      }
      dataMap[item.datetime][`Instance ${item.instance}`] = item.value;
    });

    return Object.values(dataMap);
  };

  const processedData = processUtilizationData();

  const instances = Array.from(new Set(utilizationData.map(item => item.instance)));

  const handleInstanceChange = (instance: number) => {
    setSelectedInstances(prevState => {
      if (prevState.includes(instance)) {
        return prevState.filter(i => i !== instance);
      } else {
        return [...prevState, instance];
      }
    });
  };

  const handleViewModeChange = (mode: 'all' | 'selected') => {
    setViewMode(mode);
  };

  const calculateInsights = () => {
    if (utilizationData.length === 0) return {};

    const totalUsage = utilizationData.reduce((sum, item) => sum + item.value, 0);
    const averageUsage = totalUsage / utilizationData.length;

    const groupedByDate = utilizationData.reduce((acc: { [key: string]: number }, item) => {
      const date = item.datetime.split(' ')[0];
      if (!acc[date]) {
        acc[date] = 0;
      }
      acc[date] += item.value;
      return acc;
    }, {});

    const maxUsageDay = Object.keys(groupedByDate).reduce((a, b) => (groupedByDate[a] > groupedByDate[b] ? a : b));
    const minUsageDay = Object.keys(groupedByDate).reduce((a, b) => (groupedByDate[a] < groupedByDate[b] ? a : b));

    return {
      averageUsage: averageUsage.toFixed(2),
      maxUsageDay,
      minUsageDay
    };
  };

  const potentialSavings = utilizationData.length * 0.1; // Example calculation

  return (
    <div className="app-container">
      <div className="app-overview">
        <div className="header">
          <div className="top-row">
            <div className="app-selector">
              <select
                value={selectedAppId}
                onChange={e => setSelectedAppId(e.target.value)}
              >
                <option value="">Select App</option>
                {appOptions.map(app => (
                  <option key={app.value} value={app.value}>{app.label}</option>
                ))}
              </select>
            </div>
            <div className="date-range">
              <DatePicker
                selected={startDate}
                onChange={(date: Date | null) => setStartDate(date ?? undefined)}
                selectsStart
                startDate={startDate}
                endDate={endDate}
                placeholderText="Start Date"
              />
              <DatePicker
                selected={endDate}
                onChange={(date: Date | null) => setEndDate(date ?? undefined)}
                selectsEnd
                startDate={startDate}
                endDate={endDate}
                placeholderText="End Date"
              />
            </div>
            <button className="btn primary" onClick={handleCalculate}>Calculate</button>
          </div>
          <div className="bottom-row">
            <div className="date-controls">
              <button
                className={`date-range-btn ${dateRangeType === 'daily' ? 'active' : ''}`}
                onClick={() => setDateRangeType('daily')}
              >
                Daily
              </button>
              <button
                className={`date-range-btn ${dateRangeType === 'weekly' ? 'active' : ''}`}
                onClick={() => setDateRangeType('weekly')}
              >
                Weekly
              </button>
              <button
                className={`date-range-btn ${dateRangeType === 'monthly' ? 'active' : ''}`}
                onClick={() => setDateRangeType('monthly')}
              >
                Monthly
              </button>
            </div>
            <button
              className="btn secondary"
              onClick={() => setShowInsights(true)}
            >
              Quick Insights
            </button>
          </div>
        </div>
        <div className="instance-selection">
          <div className="view-mode">
            <button
              className={`btn ${viewMode === 'all' ? 'active' : ''}`}
              onClick={() => handleViewModeChange('all')}
            >
              View All Instances
            </button>
            <button
              className={`btn ${viewMode === 'selected' ? 'active' : ''}`}
              onClick={() => handleViewModeChange('selected')}
            >
              View Selected Instances
            </button>
          </div>
          {viewMode === 'selected' && (
            <div className="instance-checkboxes">
              {instances.map(instance => (
                <label key={instance}>
                  <input
                    type="checkbox"
                    checked={selectedInstances.includes(instance)}
                    onChange={() => handleInstanceChange(instance)}
                  />
                  {`Instance ${instance}`}
                </label>
              ))}
            </div>
          )}
        </div>
        <div className="chart-container">
          <ResponsiveContainer width="100%" height={400}>
            <LineChart data={processedData} margin={{ top: 20, right: 30, left: 20, bottom: 10 }}>
              <CartesianGrid strokeDasharray="3 3" />
              <XAxis dataKey="name" />
              <YAxis />
              <Tooltip />
              <Legend />
              {instances.map((instance, index) => (
                (viewMode === 'all' || selectedInstances.includes(instance)) && (
                  <Line
                    key={instance}
                    type="monotone"
                    dataKey={`Instance ${instance}`}
                    stroke={`hsl(${index * 360 / instances.length}, 70%, 50%)`}
                    dot={false}
                  />
                )
              ))}
              <Brush dataKey="name" height={30} stroke="#8884d8" />
            </LineChart>
          </ResponsiveContainer>
        </div>
        {showInsights && (
          <div className="overlay">
            <div className="insights-popup">
              <button onClick={() => setShowInsights(false)}>Close</button>
              <div className="insights">
                <h3>Quick Insights</h3>
                <p><strong>Average Usage:</strong> {calculateInsights().averageUsage}%</p>
                <p><strong>Highest Usage Day:</strong> {calculateInsights().maxUsageDay}</p>
                <p><strong>Lowest Usage Day:</strong> {calculateInsights().minUsageDay}</p>
              </div>
            </div>
          </div>
        )}
      </div>
      <div className="export-container">
        <span className="potential-savings">Potential Savings: ${potentialSavings.toFixed(2)}</span>
        <CSVLink
          data={processedData}
          filename={"utilization-data.csv"}
          className="btn secondary"
        >
          Export CSV
        </CSVLink>
      </div>
    </div>
  );
};

export default Latestappover;
